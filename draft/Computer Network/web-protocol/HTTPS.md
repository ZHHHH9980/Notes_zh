# HTTPS

之前一直有一个疑惑，在wireshark里面抓不到HTTPS相关的包，google了一下需要进行一些配置才行。

只要把ssl.key这个文件配置到wireshark里就可以解密：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e8763a17c448aea0f7530ec26bf3e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

解密后：

![image.png](https://s2.loli.net/2023/03/04/xERgC1u7b94taBr.png)

原理到底是什么？

## 加密种类

1. 不可逆加密。 比如 MD5、SHA、HMAC

    > 典型用途：
    密码总不能明文存到数据库吧，所以一般加密存起来，只要用户的输入经过同样的加密算法 对比一下就知道密码是否正确了，所以没必要可逆

2. 可逆加密

    - 对称加密。比如：AES、DES、3DES、IDEA、RC4、RC5、RC6

        > 典型用途：
        用同一个密码加密和解密，太常见了，我用密码加密文件发给你，你只能用我的密码才能解开

    - 非对称加密（就是公私钥）。比如：RSA、DSA、ECC

        > 典型用途：
        1.加密（保证数据安全性）使用公钥加密，需使用私钥解密。
        2.认证（用于身份判断）使用私钥签名，需使用公钥验证签名。

### HTTPS 的加密种类

非对称加密与对称加密的组合。

### 为什么不只用对称加密？
如果两方各自持有同一个密钥且没有第三方知晓，那么通信安全是可以保证的，可问题是双方如何传输这个密钥让对方知晓，而不会被第三方截获，显然无论怎么传都有会被截获。

### 为什么不只用非对称加密？

服务器 => 浏览器通道：服务器生成公私钥，将公钥明文传给浏览器，浏览器通过公钥加密传给服务器，服务器用私钥解密

浏览器 => 服务器通道：浏览器生成公私钥，将公钥明文传给服务器，服务器通过公钥加密传给浏览器，浏览器用私钥解密

这样似乎可以保证双方通信是安全的，但是非对称加密非常耗时，尤其是加密解密一些大数据的时候效率较低。

### 非对称加密+对称加密

上面提到过非对称加密的过程，服务器 => 浏览器通道。这里有个问题，如果传递被第三方截获，第三方将服务器公钥保留，并且发送自己生成的公钥给浏览器，做一个中间转发，那么就可以获取到数据且能保证传输。

那么就需要解决服务器公钥是否可信任的问题。

#### 数字证书

身份证之所以可信，是因为背后是国家，那数字证书如何才可信呢？这个时候找CA（Certificate Authority）机构。办身份证需要填写自己的各种信息，去CA机构申请证书需要什么呢？至少应该有以下几项吧

1. 网站域名
2. 证书持有者
3. 证书有效期
4. 证书颁发机构
5. **服务器公钥（最主要）**
6. 接下来要说的签名时用的hash算法

#### 什么是数字签名？签名的过程是什么
签名的过程其实也很简单

1. CA机构拥有非对称加密的私钥和公钥
2. CA对证书明文信息进行hash
3. 对hash后的值用私钥加密，得到数字签名

所以呢，总结一下：CA机构颁发的证书包含（证书内容的明文+签名）

浏览器收到服务下发的证书之后，拿到证书明文和签名，怎么验证是否篡改了呢？
大家知道，私钥签名，公钥验签。证书里面的签名是CA机构用私钥签名的，所以我只要用CA机构的公钥验证一下签名不就好了，怎么验证呢？
还记得证书里面的明文包含什么吧，不记得的话看看上面的内容。

1. 拿到证书里面明文的hash算法并对明文内容进行hash运算，得到A
2. 用CA的公钥解密签名得到B
3. 比较A 和 B，如果相等，说明没有被篡改，否则浏览器提示证书不可信

通过验证证书就可以确认公钥是否来自网站真实服务器，而不是第三方。

## HTTPS 握手过程

### TLS1.2 握手

1. 首先是三次握手，HTTP是基于TCP的协议
2. 第一阶段是TLS四次握手，这一阶段主要利用**非对称加密**的特性交换信息，最后得到一个“会话密钥”(session key)。
3. 第二阶段则是在第一阶段的“会话密钥“上，进行**对称加密**通信。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1de165d23ef940788ff093cbdc374e2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

第一阶段TLS四次握手：

#### 第一次握手：

- Client Hello: 客服端通知服务端，支持的协议版本比如TLS1.2，加密套件，同时给出一个**客服端随机数**(Client Random)。

#### 第二次握手：

- Server Hello: 服务端通知客户端，**服务器随机数(server_ramdon)** + 服务器证书 + 确定的加密协议版本。

#### 第三次握手：

- Client Key Exchange: 客服端再次生成一个随机数(`pre_master_key`)。从第二次握手中的服务器证书中取出服务器公钥，用公钥加密`pre_master_key`，发给服务器。

- Change Cipher Spec: 客户端已经拥有**三个随机数**：`client_random`,`server_random`,`pre_master_key`，用这三个随机数计算生成一个”会话密钥“(session key)。此时客户端通知服务端，之后用这个”会话密钥“进行通信。

- Encryted Handshake Message: 客户端会把迄今为止的通信数据内容生成一个摘要，用“会话密钥”加密，发给服务器做校验，此时客户端握手流程结束，也称作`Finished`报文。

#### 第四次握手：

- Change Cipher Spec: 服务端此时获取到客户端传过来的`pre_master_key`，跟客户端一样用三个随机数通过同样的算法获取一个“会话密钥”，通知客户端后续该用“会话密钥”通信

- Encryted Handshake Messsage: 跟第三次握手同理


四次握手中，客户端和服务端最后都拥有三个随机数，他们很关键，我特地加粗了表示。

第一次握手，产生的客户端随机数，叫`client random`。

第二次握手时，服务器也会产生一个服务器随机数，叫`server random`。

第三次握手时，客户端还会产生一个随机数，叫`pre_master_key`。

这三个随机数共同构成最终的对称加密秘钥，也就是上面提到的"会话秘钥"。
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec6a6546979f4c1a9b4d43b2deea8751~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
你可以简单的认为，只要知道这三个随机数，你就能破解HTTPS通信。

而这三个随机数中，`client random` 和 `server random` 都是明文的，谁都能知道。而`pre_master_key`却不行，它被服务器的公钥加密过，只有客户端自己，和拥有对应服务器私钥的人能知道。

所以问题就变成了，怎么才能得到这个`pre_master_key`？

步骤一：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7e92fee619049e2a838b53442bb8608~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)


步骤二：

![image.png](https://s2.loli.net/2023/03/04/9qFnCpuTMLIsxJZ.png)

那么可以wirshark通过匹配`client random`就可以获取到`pre_master_key`，集齐三个随机数就可以对数据包进行解密。

## 小结

1. TLS前两次握手主要是交换各自的随机数和证书，以此来验证对方的身份。
2. 后两次握手各自发送一个收尾的消息，包含两个部分：
    1. `Change Cipher Spec`意味着后边要进行使用“会话密钥”进行加密传输了
    2. `Finished`，对之前所有发送过的数据做一个摘要，使用“会话密钥”加密，让对方校验


## TLS1.3 做了哪些优化？

### 强化安全
废除了一些密码套件。
最后只保留五个加密套件:

- TLS_AES_128_GCM_SHA256
- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_SHA256
- TLS_AES_128_GCM_SHA256
- TLS_AES_128_GCM_8_SHA256


### 提升性能

在TLS1.2中需要四次握手，需要2RTT(round trip time)，由于密码套件的大幅度简化，就没有必要像以前那样进行`Key Exchange`，1.3删去了这个步骤。

具体是通过扩展，直接将支持的算法参数放入`supported_groups`，让服务端来选择具体的算法。

服务端选择后在`key_share`返回服务器选择的参数，这样双方都可以各自集齐两张随机数计算后续的“会话密钥”了。

![image.png](https://s2.loli.net/2023/03/04/5FZahw8Mdn9Lm3A.png)

### 会话复用

两种方式：
1. Session ID
2. Session Ticket

#### Session ID
Session ID具体做法是客服端和服务器首次连接后各自保存一份会话ID，并且存储会话密钥，再次连接时，客户端直接发送ID，服务器查找这个ID是否已经存在，如果找到了直接复用之前的会话状态，就不用重新生成“会话密钥”

劣势：如果客户端数量庞大，服务器存储的压力非常大。

#### Session Ticket

思路是：服务器压力大，就把压力分摊给客户端。双方连接成功后，服务器加密会话信息，用`Session Ticket`消息发送给客户端，让客户端保存下来。下次重新连接的时候，就发送这个Ticket，服务端进行校验，如果没过期就恢复之前的会话状态。

#### PSK
刚刚说的都是1-RTT情况下的优化，那能不能优化到0-RTT呢？

答案是可以的。做法其实也很简单，在发送Session Ticket的同时带上应用数据，不用等到服务端确认，这种方式被称为Pre-Shared Key，即 PSK。

## 参考

[（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系](https://juejin.cn/post/6844904100035821575#heading-74)

[SSL, TLS, HTTPS Explained](https://www.youtube.com/watch?v=j9QmMEWmcfo)

[刨根问底系列之https详细握手过程](https://juejin.cn/post/6847902219745181709)

[刨根问底系列之https到底是如何防篡改的？面试必备](https://juejin.cn/post/6845166890675863559)

[为什么我抓不到baidu的数据包](https://juejin.cn/post/7165737844613316638)