# LRU (least recently used)

LRU 是基于 双向链表+哈希表 的结合。

预期行为：

```js
/* 缓存容量为 2 */
const cache = new LRUCache(2);
// 你可以把 cache 理解成一个队列
// 假设左边是队头，右边是队尾
// 最近使用的排在队尾，久未使用的排在对头
// 圆括号表示键值对 (key, val)

cache.put(1, 1);
// cache = [(1, 1)]

cache.put(2, 2);
// cache = [(2, 2), (1, 1)]

cache.get(1); // 返回 1
// cache = [(1, 1), (2, 2)]
// 解释：因为最近访问了键 1，所以提前至队头
// 返回键 1 对应的值 1

cache.put(3, 3);
// cache = [(3, 3), (1, 1)]
// 解释：缓存容量已满，需要删除内容空出位置
// 优先删除久未使用的数据，也就是队尾的数据
// 然后把新的数据插入队头

cache.get(2); // 返回 -1 (未找到)
// cache = [(3, 3), (1, 1)]
// 解释：cache 中不存在键为 2 的数据

cache.put(1, 4);
// cache = [(1, 4), (3, 3)]
// 解释：键 1 已存在，把原始值 1 覆盖为 4
// 不要忘了也要将键值对提前到队头
```

要保证增删改查的效率都是 O(1)级别，并且存储要有时间顺序。
哈希表的增删改查复杂度都在 O(1)，但是没有顺序，链表虽然能保证添加操作存在时间顺序，但是查找的复杂度在 O(n)级别。
因此要将二者结合才能实现。

[![img](https://labuladong.github.io/algo/images/LRU%e7%ae%97%e6%b3%95/4.jpg)

## 两个麻烦点

1. 增删改查这些 api 往往需要同时操作两个数据结构，很容易漏掉另一个，因此最好再抽象一层，由某个特定的 api 同时操作两个数据结构，就不会出现遗漏。

2. `put`这个 api 逻辑稍微复杂一点点，需要考虑是否存在，是否超出容量等情况。
   ![img](https://labuladong.github.io/algo/images/LRU%e7%ae%97%e6%b3%95/put.jpg)
